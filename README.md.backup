# Oryx System V0.1

## Project Description
This project aims to develop an abstracted "pseudo-OS" that will perform varying different management and organisation tasks, due to a dissatisfaction with the way Windows operates and provides its services. It will act as a centralised platform for launching applications, managing files on the system, as well as providing an extensible "toolset" for implementing custom tools, such as encrypted messaging, a custom file explorer, torrent downloader, hardware and network monitoring as well as many other possible tools.

This project is not designed to solve any problem in particular, but to act as a base project from where I can learn and expand my skills for all sorts of things. Eventually, other languages will be implemented for low-level access to certain Windows APIs

## Custom Domain Language
The application will utilise Node.js Electrons chromium based UI, which will communicate with the backend via IPC. For simplicity, the IPC will consist of a single handle, "run-command". Each tool on the system (either a core service or a tool implemented as part of "secondary" services) will provide its own syntax to a command processor for asking it to do things. The command processor builds a syntax tree for all tools on the system and will first verify that the command passed from the front-end is valid syntax.

 Each command passed from the front-end will be accompanied by a short-lived access token that is verified first by the core application Security service, before the command is parsed, verified, and passed to the appropriate tool (barring a single command for first authenticating with the application on startup with a password). Any returning data from the tool is passed back to the front-end. 
 
 ## Dynamic Service/Tool loading
 
 
Services/Tools are seperated into two seperate types; core and secondary. Core services are loaded before authentication, with all secondary tools loaded after such. Secondary tools are designed to be the ones users can implement their own for. Each services main file most extend the existing ToolAbstract class, and make use where appropriate of the init method and constructor. The signatures of these methods however must not be changed, as the tool loader expects a certain signature for each tool. At the root of each secondary tool directory, must be a TOOLNAMEMain.mjs, and a TOOLNAME.ocf (oryx command format). Any config file is loaded by the tool itself. It is important that the name of the tools root directory matches the names throughout (case sensitive) due to how the tool loader recognises and loads tools.

## Currently Planned Services


### Planned Secondary Services:

- Torrent downloader
- Hardware and network monitoring with customisable alerts
- Music Streamer
- File Explorer
- Encrypted Messaging (requires developing a seperate client for recipients, either desktop or mobile native)
- Discord API implement
- Bungie API implement
- Photo and Video viewer
- Abstract console for running domain commands
- AI Voice assistant

### Planned Core Services

- Centralised hardware service for interacting with and monitoring hardware components
- Centralised Security service to handle all security logic for the application
- Centralised Library service acting as a dependency manager for all core and secondary services (where core services can request one another, secondary services can access core, and where all services can request node libraries)
- FileSystem service where all file system interaction occurs
- Console service where every service can register events that can be recorded and saved. An abstract application logging service